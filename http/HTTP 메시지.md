# 3. HTTP 메시지

## 3.1. 메시지의 흐름
> HTTP 메시지 : HTTP 애플리케이션 간에 주고받은 데이터의 블록
- 클라이언트, 서버, 프락시 사이를 흐름
- '인바운드', '아웃바운드', '업스트림', '다운스트림' 용어를 사용

### 3.1.1. 메시지는 원 서버 방향을 인바운드로 하여 송신된다.
- 인바운드 : 메시지가 원 서버로 향하는 것
- 아웃바운드 : 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것

![image](https://user-images.githubusercontent.com/22893111/71709716-2f9daf00-2e3c-11ea-8547-6a26d4264674.png)

### 3.1.2 다운스트림으로 흐르는 메시지
- 모든 요청 메시지나 응답 메시지나 관계없이 다운스트림으로 흐른다.

![image](https://media.vlpt.us/images/200ok/post/9be60699-10d9-4230-9816-5ec8f530ee51/image.png) *요청에서는 프락시 1이 프락시 3의 업스트림이지만 응답에서는 프락시 3의 다운스트림이다*


## 3.2. 메시지의 각 부분
- HTTP 메시지는 단순한, 데이터의 구조화된 블록이다.
- 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함한다.
- 시작줄, 헤더 블록, 본문 부분으로 구성
    - 시작줄은 이것이 어떤 메시지인지
    - 헤더 블록은 메시지의 속성
    - 본문은 데이터를 담고 있음 > 본문 자체가 아예 없을 수도 있음
- 

### 3.2.1. 메시지 문법
- 모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.
    - 요청 메시지는 웹 서버에 어떤 동작을 요구한다.
        - 요청 메시지의 형식
        <br> <메서드> <요청 URL> <버전> </br>
        <br> <헤더> </br> 
        <br> <엔터티 본문></br>
ㅤ
    - 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다.
        -  응답 메시지의 형식
        <br> <버전> <상태 코드> <사유 구절> </br>
        <br> <헤더> </br>
ㅤ
        <br>엔터티 본문> </br>
#### 메서드
- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작(GET, HEAD, POST 등)
#### 요청 URL
- 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소
#### 버전
- 이 메시지에서 사용 중인 HTTP의 버전 > HTTP/<메이저>.<마이너>
#### 상태 코드
- 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자
#### 사유 구절
- 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구, 사유 구절은 오로지 사람에게 읽기기 위한 목적으로만 존재
#### 헤더들
- 이름, 콜론(;), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
#### 엔터티 본문
- 임의의 데이터 블록을 포함, 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈줄로 끝나야 함에 주의

### 3.2.2 시작줄
모든 HTTP 메시지는 시작줄로 시작하고, 요청메시지의 시작줄은 무엇을 해야할지, 응답메시지의 시작줄은 무슨일이 일어났는지를 말해준다.
#### 요청줄
- 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메소드와 그 동작에 대한 대상을 지칭하는 요청URL이 들어있음
- 모든 필드는 공백으로 구분
#### 응답줄
- 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어있음
- 모든 필드는 공백으로 구분
#### 메서드
- 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.
    - GET: 서버에서 어떤 문서를 가져온다
    - HEAD: 서버에서 어떤 문서에 대해 헤더만 가져온다
    - POST: 서버가 처리해야 할 데이터를 보낸다
    - PUT: 서버에 요청 메시지의 본문을 저장한다
    - TRACE: 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다
    - OPTIONS: 서버가 어떤 메서드를 수행할 수 있는지 확인한다
    - DELETE: 서버에서 문서를 제거한다
#### 상태 코드
- 클라이언트에게 무엇이 일어났는지 말해줌
- 상태코드는 각 응답 메시지의 시작줄에 담겨 반환
- 상태 코드들은 세 자리 숫자로 된 그들의 코드값을 기준으로 묶임
    - 100-199: 정보
    - 200-299: 성공
    - 300-399: 리다이렉션
    - 400-499: 클라이언트 에러
    - 500-599: 서버 에러
- 만약 익실 할수 없는 상태 코드를 받게 되면, 누군가가 현재 프로토콜의 확장으로 그것을 정의했을 가능성이 크므로 그 상태 코드를 그것이 포함되는 범주의 일반적인 구성원으로 가정하고 다루어야함
#### 사유 구절
- 응답 시작줄의 마지막 구성요소러써, 상태 코드에 대한 글로 된 설명을 제공
- 사유 구절을 상태 코드와 일대일로 대응
- 상태 코드의 사람이 이해하기 쉬운 버전
#### 버전 번호
- HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술
- HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단

### 헤더
HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다
#### 헤더 분류
- 일반 헤더
    - 요청과 응답 양쪽 모두에 나타날 수 있음
- 요청 헤더
    - 요청에 대한 부가 정보 제공
- 응답 헤더
    - 응답에 대한 부가 정보 제공
- Entity 헤더
    - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
- 확장 헤더
    - 명세에 정의되지 않은 새로운 헤더
#### 헤더를 여러 줄로 나누기
- 긴 헤더 줄은 여러 줄로 쪼개서 더 읽기 좋게 만들 수 있음
- 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야함

### 엔터티 본문
- 엔터티 본문은 HTTP 메시지의 화물이라고 할 수 있으며, HTTP가 수송하도록 설계된 것
- HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러종류의 디지털 데이터를 실어 나를 수 있다.

### 3.2.5 버전 0.9 메시지
- HTTP/0.9 메시지도 요청과 응답으로 이루어져 있지만, 요청은 그저 메서드와 요청 URL을 갖고 있을 뿐이며, 응답은 오직 엔터티로만 구성
- 이러한 단순함 때문에 다양한 상황에 대응할 수 없으며, 이후 버전에서 생긴 기능들과 애플리케이션들도 구현할 수 없음


## 3.3. 메서드

### 3.3.1. 안전한 메서드(Safe Method)
- HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의
- GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미
- 안전한 메서드의 목적은, 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것

### 3.3.2. GET
![image](https://img.velog.io/post-images/codemcd/f03c8e00-e267-11e9-a634-d9d33e59b626/HTTP3-7.png?w=1024)
- 서버에게 리소스를 달라고 요청하기 위해 쓰임
### 3.3.3. HEAD
![image](https://img.velog.io/post-images/codemcd/067248e0-e268-11e9-a4c2-fdfd8195e079/HTTP3-8.png?w=1024)
- GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려줌
- 엔티티 본문은 반환하지 않음
- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입 등)를 알아 낼수 있음
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인 가능
- 헤더를 확인하여 리소스가 변경되었는지 검사 가능

### 3.3.4. PUT
![image](https://img.velog.io/post-images/codemcd/308094c0-e268-11e9-a4c2-fdfd8195e079/HTTP3-9.png?w=1024)
- 서버에 문서를 씀
- 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 함
- 많은 웹서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구함

### 3.3.5. POST
![image](https://img.velog.io/post-images/codemcd/47fc1610-e268-11e9-a4c2-fdfd8195e079/HTTP3-10.png?w=1024)
- 서버에 입력 데이터를 전송하기 위해 설계되었고, HTML FORM을 지원하기 위해 흔히 사용됨
- 채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는곳에 보낸다

### 3.3.6. TRACE
![image](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTQXsuY4E_qvjfjXJ8EcSPjH-743SydMbU5i-JY9OTyExqkjYftNRA_ZGDdGgrswx561DY&usqp=CAU)
- 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌
- TRACE요청은 목적지 서버에서 '루프백(loopback)' 진단을 시작하고, 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다.
- 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신 보낸메시지에 대해서 확인용도로 사용

### 3.3.7. OPTIONS
![image](https://img.velog.io/post-images/codemcd/537985e0-e268-11e9-a4c2-fdfd8195e079/HTTP3-12.png?w=1024)
- 웹서버에게 여러 가지 종류의 지원 범위에 대해 물어볼수 있고, 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼수 있음

### 3.3.8. DELETE
- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청
### 3.3.9. 확장 메서드
- HTTP/1.1 명세에 정의 되지 않은 메서드로, HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공

## 3.4. 상태코드
> 상테 코드는 크게 5개로 나뉘며 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공

### 3.4.1. 100-199: 정보성 상태코드
- HTTP/1.1에서 도입되었음
- 특히 100 상태코드의 경우 HTTP 클라이언트 앤플리케이션이 서버에 언터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 건인지 확인하려고 할때 함..? 
- 100 Continue
    - 요청의 시작 부분 일부가 받아들여 졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미하며 이것을 보낸 후, 서버는 반드시 요청을 받아 응답해야함
- 101 Switching Protocols
    - 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미
#### 클라이언트와 100 Continue
- 클라이언트가 엔터티를 서버에 보내려고 하고 그전에 100 Continue응답을 기다린다면 100 Continue로 하는 Expect 요청 헤더를 보낼 필요가 있고, 아니면 보내지 말아야함
- 클라이언트 애플리케이션은 100-continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로 사용해야함
#### 서버와 100 Continue
- 서버는 100 Continue 응답을 받을 것을 의도하지 않은 클라이언트에게 100 Continue 상태코드를 보내면 안됨
> 클라 : Expect: 100-continue 포함 요청 전송!</br>
서버 : 음. 받을 수 있으니 100 Continue 상태 코드를 응답해볼까?</br>
클라 : 에잇, 그냥 계속 엔터티를 전송하자.</br>
서버 : 음? 아직 100 Continue를 보내지 않았는데 엔터티(일부 혹은 전체)가 왔네? 100 코드를 안 보내도 되겠군!</br>
서버 : 요청을 받았으니 그에 대한 응답을 해줘야겠다!
#### 프락시와 100 Continue
- 다음 홉(next-hop) 서버가 HTTP/1.1을 따르거나 혹은 어떤 버전을 따르는지 모른다면, Expect 헤더를 포함 시켜서 다음으로 전달해야 함
- 1.1 보다 이전 버전이라면 417 Expectation Failed 에러로 응답해야 함.
### 3.4.2. 성공 상태 코드
클라이언트가 요청을 보내면, 그 요청은 대게 성공한다. 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다.
### 3.4.3. 300-399: 리다이렉트 상태 코드
- 클라이언트가 관심있어하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공
- 만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디에서 찾을 수 있는지 알려주기 위해 리다이렉션 상태 코드와 Location 헤더를 보낼 수 있음
응답을 받은 브라우저는 알아서 새 위치로 이동
- 리다이렉션 상태 코드 중 몇몇 은 요청한 리소스에 대한 로컬 복사본이 서버에 있는 리소스와 비교했을 때 최신인지 확인하기 위해 사용 (그림 3-15 참고)

*302,303,307 차이*
- HTTP/1.0과 HTTP/1.1 애플리케이션이 이 상태 코드를 다루는 방식에 차이 발생
- 서버는 클라이언트 HTTP 버전을 검사하여 가장 적절한 리다이렉션 응답 상태 코드를 결정
- HTTP/1.0 클라이언트 POST 요청 -> 302 리다이렉션 상태 코드 -> Location URL을 GET 요청
- HTTP/1.1 명세는 리다이렉션을 위해 303 상태 코드를 사용
- 혼란을 막기 위해(?), HTTP/1.1 명세는 HTTP/1.1 클라이언트의 일시적인 리다이렉트를 위해 302 상태 코드 대신 307 상태 코드를 사용

### 3.4.4. 400-499: 클라이언트 에러
- 서버가 다룰 수 없는 요청이 왔을 때 발생
### 3.4.5. 500-599: 서버 에러 상태
- 서버 자체에서 에러가 밸생했을 경우 발생
- 클라이언트가 서버의 제한에 걸린 것일수 있거나 게이트웨이 리소스와 같은 서버의 보조 구성요서에서 발생한 에러일 수도 있음
- 프락시는 클라이언트의 입장에서 서버와 대화를 시도할 때 자주 에러를 만나게 됨

## 3.5. 헤더
- 헤더와 메서드는 클라이언트가 무엇을 하는지 결정하기 위해 함께 사용
- 메시지에만 사용할 수 있는 헤더, 더 일반 목적으로 사용할 수 있는 헤더, 응답과 요청 메시지 양쪽 모두에서 사용하는 헤더
### 3.5.1 일반 헤더
- 클라이언트와 서버 양쪽 모두가 사용
- 클라이언트, 서버, 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용 
    - Date 헤더 : 메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공
    - 일반 캐시 헤더 : HTTP/1.0은 HTTP 애플리케이션에게 매번 원 서버로 부터 객체를 가져오는대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더 도입
### 3.5.2 요청 헤더
- 요청 메시지를 위한 헤더
    - 누가 혹은 무엇이 요청을 보냈느지에 대한 정보나 클라이언트의 선호나 능력데 대한 정보를 제공해주고, 서버는 요청 헤더에 대한 클라이언트에게 더 나은 응답을 주기 위해 활용 할 수 있다.
- 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부과 정보를 제공
    - <b>Accept: */8 </b> : 서버에게 클라이언트가 자신의 요청에 대응하는 어떤 미디어 타입도 받아들일 것임을 의미
#### Accept 관련 헤더
- 클라이언트가 Accept 헤더를 이용해 자신의 선호와 능력을 알려줄 수 있고 서버는 이 정보를 이용해 더 스마트하게 응답을 보낼 있음
- Accept 헤더를 이용해 클라이언트는 자신이 원하는 정보를 얻을 수 있고, 서버는 클라이언트가 사용할 수 없는 것을 전송하는데 시간과 대역폭을 낭비하지 않을 수 있음  
#### 조건부 요청 헤더
- 클라이언트가 요청에 제약을 넣을 때 사용
- 클라이언트가 이미 어떤 문서의 사본을 가지고 있는 상태라면, 서버에게 그 문서를 요청할 때 자신이 갖고 있는 사본과 다를 때만 전송해달라고 요청할 수 있음
#### 요청 보안 헤더
- HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있음
- 클라이언트가 리소스에 접근하기 전에 자신을 인증함으로써 트랜잭션은 좀 더 안전하게 함
#### 프락시 요청 헤더
- 프락시의 기능을 돕기 위한 헤더
### 3.5.3 응답 헤더
- 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있음
    - <b>Server: Tiki-Hut/1.0 </b> : 클라이언트에게 그가 Tiki-Hut 서버 1.0 버전과 대화하고 있음을 의미
- 클라이언트에게 부가 정보를 제공
- 누가 응답을 보내는지, 응답자의 능력은 어떻게 되는지 등을 제공하며 클라이언트가 응답을 더 잘 다룰 수 있도록 도움을 줌
#### 협상 헤더
- 서버에 여러가지 표현(다국어로 번역된 HTML 문서등) 대해 HTTP/1.1은 서버와 클라이언트가 어떤 표현을 가진 리소스를 선택할 것인지 협상한다.
#### 응답 보안 헤더

### 3.5.4 엔터티 헤더
- 엔터티 본문에 대한 헤더
    - Content-Type : text/html; charset=iso-latin-1
- 요청과 응답 양쪽 모두 엔터티 헤더를 포함가능
- 엔터티 헤더는 엔터티에 대한 정보를 제공
#### 콘텐츠 헤더
- 콘텐츠 헤더는 엔터티의 콘텐츠에 대한 구체적인 정보를 제공
#### 엔터티 캐싱 헤더
- 일반 캐싱 헤더는 언제 어떻게 캐시가 되어야 하는지에 대한 지시자를 제공
    - 리소스에 대한 캐시된 사본이 아직 유효한지에 대한 정보
    - 캐시된 리소스가 더 이상 유효하지 않게 되는 시점을 더 잘 추정하기위한 단서 등
### 3.5.5. 확장헤더
- 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 면세에는 추가되니 않은 비표준 헤더